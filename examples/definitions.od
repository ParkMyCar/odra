// ideas for forward-looking macros
// it should be obvious what they consume without looking up the definition

// idea 1 - macros always consume just one following token, with blocks being special cased (consumes until braces are balanced)
// this results in names being in weird places
macro { myMacro
    // ...
}

// idea 2 - macros include their arity in the name (both in definition and in usage)
// here the macro/2 macro is used to define a new macro, myMacro/2; both macros consume 2 following tokens (rules about blocks still hold)
macro/2 myMacro/2 {
    // ...
}

// idea 3 - similar to idea 2, but the arity is conveyed by sigils (to be bikeshed)
// here `:` means that the macro consumes two following tokens (I need to add some definition at the top of this document so I don't need to repeat the stuff about blocks)
// we could use a convention of "consume as many things as there is dots following the identifier", so 
//   `myMacro.` would consume one thing (`myMacro!` would also be a nice alternative),
//   `myMacro:` two things,
//   `myMacroâ‹®` (vertical ellipsis, hard to type on purpose) three things
macro: myMacro: {
    // ...
}

// idea 4 - mix of idea 2 and 3, basically make `myMacro:` and `myMacro/2` synonymous, use whichever fits better in the context
macro: myMacro/2 {
    // ...
}

// idea 5 - `myMacro:` consumes either:
// (1) single following block
// (2) a token followed by a block
// (3) a single token if it's not followed by a block (rule 2 works in that case)
//
// this is nice, because forward-looking macros would be easily identifiable by just the `:` sigil
// this is bad, because it's not as simple as the other ideas